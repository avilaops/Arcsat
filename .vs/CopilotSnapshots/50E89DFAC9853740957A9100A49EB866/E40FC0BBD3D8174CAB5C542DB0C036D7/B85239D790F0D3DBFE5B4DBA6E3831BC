use crate::{
    auth::Claims,
    db::DbPool,
    error::{AppError, Result},
    models::*,
};
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::Json,
    routing::{get, patch, post},
    Router,
};
use rust_decimal::Decimal;
use std::sync::Arc;
use uuid::Uuid;
use validator::Validate;

pub fn routes(pool: DbPool) -> Router {
    Router::new()
        // Leads
        .route("/leads", post(create_lead).get(list_leads))
        .route("/leads/:id", get(get_lead).patch(update_lead).delete(delete_lead))
        .route("/leads/:id/stage", patch(update_lead_stage))
        .route("/leads/:id/history", get(get_lead_history))
        
        // Opportunities
        .route("/opportunities/forecast", get(sales_forecast))
        .route("/opportunities/pipeline", get(pipeline_view))
        
        // Accounts
        .route("/accounts", post(create_account).get(list_accounts))
        .route("/accounts/:id", get(get_account))
        .route("/accounts/:id/health-score", get(account_health_score))
        
        // Activities
        .route("/activities", post(create_activity).get(list_activities))
        .route("/activities/:id", get(get_activity).patch(update_activity))
        
        // Contacts
        .route("/contacts", post(create_contact).get(list_contacts))
        .route("/contacts/:id", get(get_contact))
        
        .with_state(Arc::new(pool))
}

// ============================================================================
// LEADS HANDLERS
// ============================================================================

/// Criar novo lead
async fn create_lead(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
    Json(payload): Json<CreateLeadRequest>,
) -> Result<(StatusCode, Json<LeadResponse>)> {
    payload.validate()
        .map_err(|e| AppError::validation_error(e.to_string()))?;

    let lead_id = Uuid::new_v4();
    let tenant_id = Uuid::parse_str(&claims.tenant_id)?;
    let owner_id = Uuid::parse_str(&claims.sub)?;
    
    // Calcular score do lead com IA
    let score = calculate_lead_score(&payload);
    
    // Inserir lead
    let lead = sqlx::query_as!(
        Lead,
        r#"
        INSERT INTO crm_leads 
            (id, tenant_id, name, company, email, phone, source, stage, score, value, 
             probability, owner_id, expected_close_date, custom_fields)
        VALUES 
            ($1, $2, $3, $4, $5, $6, $7::lead_source, $8::lead_stage, $9, $10, 20, $11, $12, $13)
        RETURNING 
            id, tenant_id, name, company, email, phone,
            source as "source: LeadSource",
            stage as "stage: LeadStage",
            score, value, probability, owner_id, 
            expected_close_date, actual_close_date, lost_reason,
            custom_fields as "custom_fields: serde_json::Value",
            created_at, updated_at
        "#,
        lead_id,
        tenant_id,
        payload.name,
        payload.company,
        payload.email,
        payload.phone,
        payload.source as LeadSource,
        LeadStage::New as LeadStage,
        score,
        Decimal::from_f64_retain(payload.value).unwrap(),
        owner_id,
        payload.expected_close_date,
        payload.custom_fields,
    )
    .fetch_one(pool.as_ref())
    .await?;

    // Buscar informações do owner
    let owner = get_user_summary(&pool, owner_id).await?;

    let response = LeadResponse {
        id: lead.id,
        name: lead.name,
        company: lead.company,
        email: lead.email,
        phone: lead.phone,
        source: lead.source,
        stage: lead.stage,
        score: lead.score,
        value: lead.value.to_string(),
        probability: lead.probability,
        owner,
        created_at: lead.created_at,
        last_contact: None, // TODO: Query última atividade
    };

    tracing::info!("Lead created: {} by user {}", lead_id, claims.sub);

    Ok((StatusCode::CREATED, Json(response)))
}

/// Listar leads com filtros avançados
async fn list_leads(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
    Query(query): Query<ListLeadsQuery>,
) -> Result<Json<PaginatedResponse<LeadResponse>>> {
    let tenant_id = Uuid::parse_str(&claims.tenant_id)?;
    
    let page = query.page.unwrap_or(1).max(1);
    let limit = query.limit.unwrap_or(50).min(100);
    let offset = (page - 1) * limit;

    // Contar total (com filtros)
    let total_items = sqlx::query_scalar::<_, i64>(
        r#"
        SELECT COUNT(*)
        FROM crm_leads
        WHERE tenant_id = $1
          AND ($2::lead_stage IS NULL OR stage = $2::lead_stage)
          AND ($3::integer IS NULL OR score >= $3)
          AND ($4::uuid IS NULL OR owner_id = $4)
          AND ($5::lead_source IS NULL OR source = $5::lead_source)
        "#
    )
    .bind(tenant_id)
    .bind(query.stage.as_ref())
    .bind(query.score_min)
    .bind(query.owner_id)
    .bind(query.source.as_ref())
    .fetch_one(pool.as_ref())
    .await?;

    // Buscar leads
    let leads = sqlx::query_as!(
        Lead,
        r#"
        SELECT 
            id, tenant_id, name, company, email, phone,
            source as "source: LeadSource",
            stage as "stage: LeadStage",
            score, value, probability, owner_id,
            expected_close_date, actual_close_date, lost_reason,
            custom_fields as "custom_fields: serde_json::Value",
            created_at, updated_at
        FROM crm_leads 
        WHERE tenant_id = $1
          AND ($2::lead_stage IS NULL OR stage = $2::lead_stage)
          AND ($3::integer IS NULL OR score >= $3)
          AND ($4::uuid IS NULL OR owner_id = $4)
          AND ($5::lead_source IS NULL OR source = $5::lead_source)
        ORDER BY score DESC, created_at DESC
        LIMIT $6 OFFSET $7
        "#,
        tenant_id,
        query.stage as Option<LeadStage>,
        query.score_min,
        query.owner_id,
        query.source as Option<LeadSource>,
        limit as i64,
        offset as i64,
    )
    .fetch_all(pool.as_ref())
    .await?;

    // Mapear para response
    let mut data = Vec::new();
    for lead in leads {
        let owner = get_user_summary(&pool, lead.owner_id).await?;
        data.push(LeadResponse {
            id: lead.id,
            name: lead.name,
            company: lead.company,
            email: lead.email,
            phone: lead.phone,
            source: lead.source,
            stage: lead.stage,
            score: lead.score,
            value: lead.value.to_string(),
            probability: lead.probability,
            owner,
            created_at: lead.created_at,
            last_contact: None,
        });
    }

    Ok(Json(PaginatedResponse::new(data, page, limit, total_items)))
}

/// Obter lead por ID
async fn get_lead(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
    Path(id): Path<Uuid>,
) -> Result<Json<Lead>> {
    let tenant_id = Uuid::parse_str(&claims.tenant_id)?;

    let lead = sqlx::query_as!(
        Lead,
        r#"
        SELECT 
            id, tenant_id, name, company, email, phone,
            source as "source: LeadSource",
            stage as "stage: LeadStage",
            score, value, probability, owner_id,
            expected_close_date, actual_close_date, lost_reason,
            custom_fields as "custom_fields: serde_json::Value",
            created_at, updated_at
        FROM crm_leads
        WHERE id = $1 AND tenant_id = $2
        "#,
        id,
        tenant_id
    )
    .fetch_optional(pool.as_ref())
    .await?
    .ok_or_else(|| AppError::not_found("Lead"))?;

    Ok(Json(lead))
}

/// Atualizar lead
async fn update_lead(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
    Path(id): Path<Uuid>,
    Json(payload): Json<CreateLeadRequest>, // Reusar mesmo payload
) -> Result<Json<Lead>> {
    payload.validate()
        .map_err(|e| AppError::validation_error(e.to_string()))?;

    let tenant_id = Uuid::parse_str(&claims.tenant_id)?;

    let lead = sqlx::query_as!(
        Lead,
        r#"
        UPDATE crm_leads 
        SET 
            name = $1,
            company = $2,
            email = $3,
            phone = $4,
            source = $5::lead_source,
            value = $6,
            expected_close_date = $7,
            custom_fields = $8,
            updated_at = NOW()
        WHERE id = $9 AND tenant_id = $10
        RETURNING 
            id, tenant_id, name, company, email, phone,
            source as "source: LeadSource",
            stage as "stage: LeadStage",
            score, value, probability, owner_id,
            expected_close_date, actual_close_date, lost_reason,
            custom_fields as "custom_fields: serde_json::Value",
            created_at, updated_at
        "#,
        payload.name,
        payload.company,
        payload.email,
        payload.phone,
        payload.source as LeadSource,
        Decimal::from_f64_retain(payload.value).unwrap(),
        payload.expected_close_date,
        payload.custom_fields,
        id,
        tenant_id,
    )
    .fetch_optional(pool.as_ref())
    .await?
    .ok_or_else(|| AppError::not_found("Lead"))?;

    Ok(Json(lead))
}

/// Deletar lead (soft delete)
async fn delete_lead(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
    Path(id): Path<Uuid>,
) -> Result<StatusCode> {
    let tenant_id = Uuid::parse_str(&claims.tenant_id)?;

    // TODO: Implementar soft delete (adicionar coluna deleted_at)
    let result = sqlx::query!(
        "DELETE FROM crm_leads WHERE id = $1 AND tenant_id = $2",
        id,
        tenant_id
    )
    .execute(pool.as_ref())
    .await?;

    if result.rows_affected() == 0 {
        return Err(AppError::not_found("Lead"));
    }

    Ok(StatusCode::NO_CONTENT)
}

/// Atualizar estágio do lead (drag & drop no kanban)
async fn update_lead_stage(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
    Path(lead_id): Path<Uuid>,
    Json(payload): Json<UpdateLeadStageRequest>,
) -> Result<Json<Lead>> {
    let tenant_id = Uuid::parse_str(&claims.tenant_id)?;

    // Calcular nova probabilidade
    let probability = calculate_probability(&payload.stage);

    // Atualizar lead
    let lead = sqlx::query_as!(
        Lead,
        r#"
        UPDATE crm_leads 
        SET 
            stage = $1::lead_stage,
            probability = $2,
            lost_reason = $3,
            actual_close_date = CASE 
                WHEN $1::text IN ('won', 'lost') THEN CURRENT_DATE 
                ELSE actual_close_date 
            END,
            updated_at = NOW()
        WHERE id = $4 AND tenant_id = $5
        RETURNING 
            id, tenant_id, name, company, email, phone,
            source as "source: LeadSource",
            stage as "stage: LeadStage",
            score, value, probability, owner_id,
            expected_close_date, actual_close_date, lost_reason,
            custom_fields as "custom_fields: serde_json::Value",
            created_at, updated_at
        "#,
        payload.stage as LeadStage,
        probability,
        payload.reason,
        lead_id,
        tenant_id,
    )
    .fetch_optional(pool.as_ref())
    .await?
    .ok_or_else(|| AppError::not_found("Lead"))?;

    // Registrar no histórico (trigger do banco faz isso automaticamente)
    
    tracing::info!("Lead {} moved to stage {:?}", lead_id, payload.stage);

    Ok(Json(lead))
}

/// Histórico de mudanças de estágio
async fn get_lead_history(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
    Path(lead_id): Path<Uuid>,
) -> Result<Json<Vec<LeadStageHistory>>> {
    let tenant_id = Uuid::parse_str(&claims.tenant_id)?;

    // Verificar se lead pertence ao tenant
    let _lead = sqlx::query!("SELECT id FROM crm_leads WHERE id = $1 AND tenant_id = $2", lead_id, tenant_id)
        .fetch_optional(pool.as_ref())
        .await?
        .ok_or_else(|| AppError::not_found("Lead"))?;

    let history = sqlx::query_as!(
        LeadStageHistory,
        r#"
        SELECT 
            id, lead_id,
            from_stage as "from_stage: Option<LeadStage>",
            to_stage as "to_stage: LeadStage",
            reason, changed_by, duration_seconds, changed_at
        FROM crm_lead_stage_history
        WHERE lead_id = $1
        ORDER BY changed_at DESC
        "#,
        lead_id
    )
    .fetch_all(pool.as_ref())
    .await?;

    Ok(Json(history))
}

// ============================================================================
// OPPORTUNITIES & FORECAST
// ============================================================================

/// Forecast de vendas com IA
async fn sales_forecast(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
) -> Result<Json<ForecastResponse>> {
    let tenant_id = Uuid::parse_str(&claims.tenant_id)?;

    let result = sqlx::query!(
        r#"
        SELECT 
            stage as "stage: LeadStage",
            COUNT(*) as "count!",
            COALESCE(SUM(value), 0) as "total_value!: Decimal",
            COALESCE(AVG(probability), 0) as "avg_probability!"
        FROM crm_leads
        WHERE tenant_id = $1 
          AND stage NOT IN ('won', 'lost')
        GROUP BY stage
        "#,
        tenant_id
    )
    .fetch_all(pool.as_ref())
    .await?;

    let mut weighted_total = 0.0;
    let mut breakdown = serde_json::Map::new();

    for row in result {
        let total = row.total_value.to_f64().unwrap_or(0.0);
        let prob = row.avg_probability;
        let stage_value = total * (prob / 100.0);
        weighted_total += stage_value;

        breakdown.insert(
            format!("{:?}", row.stage).to_lowercase(),
            serde_json::json!({
                "count": row.count,
                "value": total,
                "probability": prob
            }),
        );
    }

    Ok(Json(ForecastResponse {
        period: "Q1-2024".to_string(),
        forecast: ForecastValues {
            best_case: weighted_total * 1.35,
            most_likely: weighted_total,
            worst_case: weighted_total * 0.65,
            weighted: weighted_total,
        },
        breakdown_by_stage: serde_json::Value::Object(breakdown),
    }))
}

/// Pipeline visual (Kanban)
async fn pipeline_view(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
) -> Result<Json<serde_json::Value>> {
    let tenant_id = Uuid::parse_str(&claims.tenant_id)?;

    let leads = sqlx::query_as!(
        Lead,
        r#"
        SELECT 
            id, tenant_id, name, company, email, phone,
            source as "source: LeadSource",
            stage as "stage: LeadStage",
            score, value, probability, owner_id,
            expected_close_date, actual_close_date, lost_reason,
            custom_fields as "custom_fields: serde_json::Value",
            created_at, updated_at
        FROM crm_leads 
        WHERE tenant_id = $1
          AND stage NOT IN ('won', 'lost')
        ORDER BY score DESC
        "#,
        tenant_id
    )
    .fetch_all(pool.as_ref())
    .await?;

    // Agrupar por estágio
    let mut pipeline = serde_json::Map::new();
    for stage in [LeadStage::New, LeadStage::Contacted, LeadStage::Qualification, LeadStage::Proposal, LeadStage::Negotiation] {
        let stage_leads: Vec<_> = leads.iter()
            .filter(|l| l.stage == stage)
            .cloned()
            .collect();
        
        let total_value: f64 = stage_leads.iter()
            .map(|l| l.value.to_f64().unwrap_or(0.0))
            .sum();

        pipeline.insert(
            format!("{:?}", stage).to_lowercase(),
            serde_json::json!({
                "leads": stage_leads,
                "count": stage_leads.len(),
                "total_value": total_value
            })
        );
    }

    Ok(Json(serde_json::Value::Object(pipeline)))
}

// ============================================================================
// ACCOUNTS
// ============================================================================

/// Criar conta (cliente)
async fn create_account(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
    Json(payload): Json<serde_json::Value>, // TODO: Criar struct
) -> Result<(StatusCode, Json<Account>)> {
    let tenant_id = Uuid::parse_str(&claims.tenant_id)?;
    
    // TODO: Implementar criação completa
    
    Err(AppError::BadRequest("Not implemented yet".to_string()))
}

async fn list_accounts(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
) -> Result<Json<Vec<Account>>> {
    let tenant_id = Uuid::parse_str(&claims.tenant_id)?;
    
    let accounts = sqlx::query_as!(
        Account,
        r#"
        SELECT 
            id, tenant_id, name, cnpj, industry, employees_count, annual_revenue,
            website, address as "address: Option<serde_json::Value>",
            account_manager_id, health_score, status,
            custom_fields as "custom_fields: serde_json::Value",
            created_at, updated_at
        FROM crm_accounts
        WHERE tenant_id = $1
        ORDER BY name
        "#,
        tenant_id
    )
    .fetch_all(pool.as_ref())
    .await?;
    
    Ok(Json(accounts))
}

async fn get_account(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
    Path(id): Path<Uuid>,
) -> Result<Json<Account>> {
    let tenant_id = Uuid::parse_str(&claims.tenant_id)?;
    
    let account = sqlx::query_as!(
        Account,
        r#"
        SELECT 
            id, tenant_id, name, cnpj, industry, employees_count, annual_revenue,
            website, address as "address: Option<serde_json::Value>",
            account_manager_id, health_score, status,
            custom_fields as "custom_fields: serde_json::Value",
            created_at, updated_at
        FROM crm_accounts
        WHERE id = $1 AND tenant_id = $2
        "#,
        id,
        tenant_id
    )
    .fetch_optional(pool.as_ref())
    .await?
    .ok_or_else(|| AppError::not_found("Account"))?;
    
    Ok(Json(account))
}

/// Health Score do cliente (IA)
async fn account_health_score(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
    Path(account_id): Path<Uuid>,
) -> Result<Json<AccountHealthScore>> {
    let tenant_id = Uuid::parse_str(&claims.tenant_id)?;

    let account = get_account(claims, State(pool.clone()), Path(account_id)).await?.0;

    // TODO: Calcular health score real com ML
    let health_score = account.health_score.unwrap_or(75);
    let status = if health_score >= 70 {
        "healthy"
    } else if health_score >= 50 {
        "at_risk"
    } else {
        "critical"
    };

    let response = AccountHealthScore {
        account_id: account.id,
        health_score,
        status: status.to_string(),
        factors: HealthFactors {
            engagement: FactorScore { score: 85, weight: 30, trend: "up".to_string() },
            financial: FactorScore { score: 70, weight: 25, trend: "stable".to_string() },
            support_tickets: FactorScore { score: 80, weight: 20, trend: "up".to_string() },
            product_usage: FactorScore { score: 75, weight: 25, trend: "down".to_string() },
        },
        risk_indicators: vec![
            RiskIndicator {
                r#type: "low_usage".to_string(),
                severity: "medium".to_string(),
                message: "Uso do produto caiu 15% no último mês".to_string(),
            }
        ],
        recommendations: vec![
            "Agendar quarterly business review".to_string(),
            "Oferecer treinamento avançado".to_string(),
        ],
    };

    Ok(Json(response))
}

// ============================================================================
// ACTIVITIES
// ============================================================================

async fn create_activity(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
    Json(payload): Json<serde_json::Value>,
) -> Result<(StatusCode, Json<Activity>)> {
    // TODO: Implementar
    Err(AppError::BadRequest("Not implemented yet".to_string()))
}

async fn list_activities(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
) -> Result<Json<Vec<Activity>>> {
    // TODO: Implementar
    Ok(Json(vec![]))
}

async fn get_activity(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
    Path(id): Path<Uuid>,
) -> Result<Json<Activity>> {
    // TODO: Implementar
    Err(AppError::not_found("Activity"))
}

async fn update_activity(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
    Path(id): Path<Uuid>,
    Json(payload): Json<serde_json::Value>,
) -> Result<Json<Activity>> {
    // TODO: Implementar
    Err(AppError::not_found("Activity"))
}

// ============================================================================
// CONTACTS
// ============================================================================

async fn create_contact(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
    Json(payload): Json<serde_json::Value>,
) -> Result<(StatusCode, Json<Contact>)> {
    // TODO: Implementar
    Err(AppError::BadRequest("Not implemented yet".to_string()))
}

async fn list_contacts(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
) -> Result<Json<Vec<Contact>>> {
    // TODO: Implementar
    Ok(Json(vec![]))
}

async fn get_contact(
    claims: Claims,
    State(pool): State<Arc<DbPool>>,
    Path(id): Path<Uuid>,
) -> Result<Json<Contact>> {
    // TODO: Implementar
    Err(AppError::not_found("Contact"))
}

// ============================================================================
// HELPERS
// ============================================================================

/// Calcular score do lead com heurísticas (em produção, usar ML)
fn calculate_lead_score(lead: &CreateLeadRequest) -> i32 {
    let mut score = 50;

    // Fator: valor do negócio
    if lead.value > 100000.0 {
        score += 20;
    } else if lead.value > 50000.0 {
        score += 10;
    }

    // Fator: fonte do lead
    score += match lead.source {
        LeadSource::LinkedIn => 15,
        LeadSource::Referral => 20,
        LeadSource::Website => 10,
        _ => 5,
    };

    // Fator: empresa conhecida
    if lead.company.is_some() {
        score += 5;
    }

    score.min(100)
}

/// Calcular probabilidade baseado no estágio
fn calculate_probability(stage: &LeadStage) -> i32 {
    match stage {
        LeadStage::New => 10,
        LeadStage::Contacted => 15,
        LeadStage::Qualification => 25,
        LeadStage::Proposal => 60,
        LeadStage::Negotiation => 80,
        LeadStage::Won => 100,
        LeadStage::Lost => 0,
    }
}

/// Buscar resumo do usuário (cache later)
async fn get_user_summary(pool: &DbPool, user_id: Uuid) -> Result<UserSummary> {
    let user = sqlx::query!(
        "SELECT id, name, email FROM users WHERE id = $1",
        user_id
    )
    .fetch_optional(pool)
    .await?
    .ok_or_else(|| AppError::not_found("User"))?;

    Ok(UserSummary {
        id: user.id,
        name: user.name,
        email: user.email,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_calculate_lead_score() {
        let lead = CreateLeadRequest {
            name: "Test Lead".to_string(),
            company: Some("Big Corp".to_string()),
            email: "test@example.com".to_string(),
            phone: None,
            source: LeadSource::LinkedIn,
            value: 150000.0,
            expected_close_date: None,
            custom_fields: serde_json::json!({}),
        };

        let score = calculate_lead_score(&lead);
        assert!(score >= 80); // High-value LinkedIn lead deve ter score alto
    }

    #[test]
    fn test_calculate_probability() {
        assert_eq!(calculate_probability(&LeadStage::Qualification), 25);
        assert_eq!(calculate_probability(&LeadStage::Proposal), 60);
        assert_eq!(calculate_probability(&LeadStage::Won), 100);
    }
}
